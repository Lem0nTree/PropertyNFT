// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";



    /**
    * @title PropertyNFT
    * @dev An NFT representation of a property. This contract allows for minting property NFTs, updating their attributes,
    * and querying based on certain attributes like propertyID. It also provides role-based access control for various operations.
    */
contract PropertyNFT is ERC721, ERC721Enumerable, ERC721URIStorage, ReentrancyGuard  {

    /**
    * @dev Struct representing a Property with various attributes.
    */
    struct Property {
        string propertyName; // name of the property
        uint apr; // apr the property guarantee
        uint totalPropertyRaised; // total sell value of the property
        uint propertyParticipation; // amount user partecipated in the property
        uint propertyID; // id of the launchpad that sold the property
        uint redeemFees; // fees that will be paid when redeem the profit from property selling
        uint sellFees; // fees from selling the NFT in the marketplace
        uint totalEarned; // revenue generated by the NFT property over time
    }

    mapping(uint256 => Property) public properties; // Mapping of token ID to its associated Property
    mapping(uint => uint256[]) public propertyIDToTokenIds; // Mapping of launchpad ID to an array of token IDs

    

    // Role-based access controls
    address public admin;
    address public minter;
    address public redeemer;
    address public operator;

    /**
     * @dev Ensures that the caller is the admin.
     */
    modifier onlyAdmin() {
        require(msg.sender == admin, "Caller is not an admin");
        _;
    }

    /**
     * @dev Ensures that the caller has minting privileges.
     */
    modifier onlyMinter() {
        require(msg.sender == minter, "Caller is not a minter");
        _;
    }

    /**
     * @dev Ensures that the caller has redeeming privileges.
     */
    modifier onlyRedeemer() {
        require(msg.sender == redeemer, "Caller is not a redeemer");
        _;
    }

    /**
     * @dev Ensures that the caller has operational privileges.
     */
    modifier onlyOperator() {
        require(msg.sender == operator, "Caller is not an operator");
        _;
    }

    /**
    * @dev Emitted when a new property NFT is minted.
    */
    event PropertyMinted(
        uint256 tokenId,
        string propertyName,
        uint apr,
        uint totalPropertyRaised,
        uint propertyParticipation,
        uint propertyID,
        uint redeemFees,
        uint sellFees,
        uint totalEarned
    );


    /**
    * @dev Sets up the main admin role on contract deployment.
    */
    constructor() ERC721("PropertyNFT", "PNFT") {
        admin = msg.sender;  // Set deployer as the initial admin
    }


    /**
     * @dev Assigns a new admin.
     * @param _newAdmin Address of the new admin.
     */
    function setNewAdmin(address _newAdmin) public onlyAdmin {
        admin = _newAdmin;
    }

    /**
     * @dev Assigns a minter role to an address.
     * @param _minter Address to be assigned the minter role.
     */
    function setMinter(address _minter) public onlyAdmin {
        minter = _minter;
    }

    /**
     * @dev Assigns a redeemer role to an address.
     * @param _redeemer Address to be assigned the redeemer role.
     */
    function setRedeemer(address _redeemer) public onlyAdmin {
        redeemer = _redeemer;
    }

    /**
     * @dev Assigns an operator role to an address.
     * @param _operator Address to be assigned the operator role.
     */
    function setOperator(address _operator) public onlyAdmin {
        operator = _operator;
    }

    /**
    * @dev Mints a new property NFT.
    * @param to - the recipient address of the minted token.
    * @param propertyName - name of property NFT represent.
    * @param apr - APR expected from the property.
    * @param totalPropertyRaised - Total sell value of the property.
    * @param propertyParticipation - amount user partecipated in the property.
    * @param propertyID - id of the launchpad that sold the property.
    * @param redeemFees - fees that will be paid when redeem the profit from property selling.
    * @param sellFees - fees from selling the NFT in the marketplace.
    * @param totalEarned - revenue generated by the NFT property over time.
    * @notice Only callable by an address with the MinterPad role.
    */
    function mintProperty(
        address to,
        string memory propertyName,
        uint apr,
        uint totalPropertyRaised,
        uint propertyParticipation,
        uint propertyID,
        uint redeemFees,
        uint sellFees,
        uint totalEarned
    ) external onlyMinter returns (uint256) {
        uint256 newTokenId = totalSupply() + 1;
        _safeMint(to, newTokenId);

        Property memory newProperty = Property({
            propertyName: propertyName,
            apr: apr,
            totalPropertyRaised: totalPropertyRaised,
            propertyParticipation: propertyParticipation,
            propertyID: propertyID,
            redeemFees: redeemFees,
            sellFees: sellFees,
            totalEarned: totalEarned
        });

        properties[newTokenId] = newProperty;
        propertyIDToTokenIds[propertyID].push(newTokenId);

        emit PropertyMinted(
            newTokenId,
            propertyName,
            apr,
            totalPropertyRaised,
            propertyParticipation,
            propertyID,
            redeemFees,
            sellFees,
            totalEarned
        );

        return newTokenId;
    }

    /**
    * @dev Fetches all tokens associated with a particular propertyID.
    * @param _propertyID - the ID of the launchpad to query.
    * @return A list of token IDs associated with the provided propertyID.
    */
    function getTokensBypropertyID(uint _propertyID) public view returns (uint256[] memory) {
        return propertyIDToTokenIds[_propertyID];
    }


    /**
    * @dev Updates the sellFees attribute for a single  tokenIds.
    * @param tokenId - NFT token IDs.
    * @param _sellFees - the new value for sellFees to be set.
    * @notice Only callable by an operator.
    */
    function updateSellFees(uint256 tokenId, uint _sellFees) external onlyOperator {
        require(_exists(tokenId), "NFT does not exist");
        properties[tokenId].sellFees = _sellFees;
    }

    /**
    * @dev Updates the redeemfees attribute for a single  tokenIds.
    * @param tokenId - NFT token IDs.
    * @param _redeemFees - the new value for redeemfees to be set.
    * @notice Only callable by an operator.
    */
    function updateRedeemFees(uint256 tokenId, uint _redeemFees) external onlyOperator {
        require(_exists(tokenId), "NFT does not exist");
        properties[tokenId].redeemFees = _redeemFees;
    }


    /**
    * @dev Updates the sellFees attribute for a multiple tokenIds.
    * @param tokenIds - Array of NFT token IDs.
    * @param _sellFees - the new value for sellFees to be set.
    * @notice Only callable by an operator.
    */
    function updateBulkSellFees(uint256[] memory tokenIds, uint _sellFees) external onlyOperator {
        for (uint i = 0; i < tokenIds.length; i++) {
            require(_exists(tokenIds[i]), "NFT does not exist");
            properties[tokenIds[i]].sellFees = _sellFees;
        }
    }

    /**
    * @dev Updates the redeemFees attribute for a multiple tokenIds.
    * @param tokenIds - Array of NFT token IDs.
    * @param _redeemFees - the new value for redeemFees to be set.
    * @notice Only callable by an operator.
    */
    function updateBulkRedeemFees(uint256[] memory tokenIds, uint _redeemFees) external onlyOperator {
        for (uint i = 0; i < tokenIds.length; i++) {
            require(_exists(tokenIds[i]), "NFT does not exist");
            properties[tokenIds[i]].redeemFees = _redeemFees;
        }
    }

    /**
    * @dev Distributes rewards to NFT holders based on their properties' participation in a specified launchpad.
    * The rewards are distributed in USD token. The contract needs to be approved by the operator to spend the USDT before calling this function.
    *
    * @param propertyID The ID of the launchpad for which rewards are to be distributed.
    * @param amount The total amount of USD to be distributed among the NFT holders.
    * @param TokenAddress The address of the ERC20 token contract.
    *
    * Emits a `Transfer` event for each reward distribution.
    *
    * Requirements:
    * - The caller must have the `operator` role.
    * - The contract must be approved by the operator to spend at least `amount` of USDT.
    * - The total distributed amount should match the specified `amount`.
    */
    function distributeRewards(uint propertyID, uint amount, address TokenAddress) external onlyOperator nonReentrant  {
        IERC20 Token = IERC20(TokenAddress); // Initialize USD token using the provided address

        // Ensure that the operator has approved the contract to spend the required amount of USD
        require(Token.allowance(msg.sender, address(this)) >= amount, "Contract not approved to spend the required amount of USD");

        uint256[] memory tokenIDs = getTokensBypropertyID(propertyID);
        uint totalDistributed = 0; // Keep track of total USD distributed

        for (uint i = 0; i < tokenIDs.length; i++) {
            Property memory property = properties[tokenIDs[i]];
            
            uint reward = (amount * property.propertyParticipation / property.totalPropertyRaised);
            totalDistributed += reward;

            // Transfer reward to NFT owner using USDT
            Token.transferFrom(msg.sender, ownerOf(tokenIDs[i]), reward);

            // Update totalEarned for the NFT
            properties[tokenIDs[i]].totalEarned += reward;
        }

        // Ensure that the total distributed amount matches the specified amount
        // require(totalDistributed == amount, "Distributed amount does not match the specified amount");
    }



    /**
    * @dev Internal function to burn a token. Overrides the ERC721 burn functionality.
    * @param tokenId - the ID of the token to be burned.
    */
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    /**
    * @dev Allows burning of a token after user's approval.
    * @param tokenId - the ID of the token to be burned.
    * @notice Only callable by an address with the RedeemPad role.
    */
    function burnTokenWithApproval(uint256 tokenId) external onlyRedeemer {
        require(ownerOf(tokenId) == msg.sender || isApprovedForAll(ownerOf(tokenId), msg.sender), "Not approved to burn");
        _burn(tokenId);
    }

    /**
    * @dev Sets the URI for a given token ID. Overrides the ERC721URIStorage setTokenURI functionality.
    * @param tokenId - the ID of the token to set the URI for.
    * @param _tokenURI - the new URL for metadata.
    */
    function setTokenURI(uint256 tokenId, string memory _tokenURI) external onlyOperator {
        _setTokenURI(tokenId, _tokenURI);
    }

    /**
    * @dev Returns the URI associated with a specific token ID. Overrides ERC721's tokenURI functionality.
    * @param tokenId - The ID of the token to fetch the URI for.
    * @return A string representing the URI of the specified token.
    */
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    /**
    * @dev Fetches the Property details for a specific token ID.
    * @param tokenId - The ID of the token to fetch the Property details for.
    * @return A Property struct containing details about the specified property.
    */
    function getProperty(uint256 tokenId) external view returns (Property memory) {
        return properties[tokenId];
    }

    /**
    * @dev Returns the balance (number of tokens) of the specified owner. Overrides ERC721's balanceOf function.
    * @param owner - The address of the user to fetch the balance for.
    * @return The number of tokens owned by the specified address.
    */
    function balanceOf(address owner) public view virtual override(ERC721, IERC721) returns (uint256) {
        return super.balanceOf(owner);
    }

    /**
    * @dev Returns the owner of the specified token ID. Overrides ERC721's ownerOf function.
    * @param tokenId - The ID of the token to fetch the owner for.
    * @return The address of the owner of the specified token.
    */
    function ownerOf(uint256 tokenId) public view virtual override(ERC721, IERC721) returns (address) {
        return super.ownerOf(tokenId);
    }
    
    /**
    * @dev Approves another address to manage the specified token. Overrides ERC721's approve function.
    * @param to - The address to be approved.
    * @param tokenId - The ID of the token to be approved for management.
    */
    function approve(address to, uint256 tokenId) public virtual override(ERC721, IERC721) {
        super.approve(to, tokenId);
    }

    /**
    * @dev Transfers the ownership of a token from one address to another. Overrides ERC721's transferFrom function.
    * @param from - The current owner of the token.
    * @param to - The address to receive the token.
    * @param tokenId - The ID of the token to be transferred.
    */
    function transferFrom(address from, address to, uint256 tokenId) public virtual override(ERC721, IERC721) {
        super.transferFrom(from, to, tokenId);
    }

    /**
    * @dev Safely transfers the ownership of a token from one address to another. Overrides ERC721's safeTransferFrom function.
    * @param from - The current owner of the token.
    * @param to - The address to receive the token.
    * @param tokenId - The ID of the token to be transferred.
    */
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override(ERC721, IERC721) {
        super.safeTransferFrom(from, to, tokenId);
    }

    /**
    * @dev Safely transfers the ownership of a token from one address to another, with additional data. Overrides ERC721's safeTransferFrom function.
    * @param from - The current owner of the token.
    * @param to - The address to receive the token.
    * @param tokenId - The ID of the token to be transferred.
    * @param _data - Additional data to accompany the transfer.
    */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override(ERC721, IERC721) {
        super.safeTransferFrom(from, to, tokenId, _data);
    }
    
    /** Additional Overrides to avoid library conflicts */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal virtual override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize); 
    }
    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}